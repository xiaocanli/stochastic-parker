#!/usr/bin/env python3
"""
Module of 3D data of termination shocks generated by Athena MHD code
"""
import multiprocessing
from joblib import Parallel, delayed

import numpy as np

from athena_vtk_reader import read

mhd_run_path = "/pscratch/sd/x/xiaocan/mhd/termination_shocks/3d_run1/"
out_dir = mhd_run_path + "bin_data/"
tmin = 0
tmax = 315
zboundary_open = True


def save_config(x, y, z):
    """Save configuration data
    """
    double_data = np.zeros(13)
    int_data = np.zeros(14, dtype=np.int32)
    nx = len(x)
    ny = len(y)
    nz = len(z)
    nx_mhd = nx - 3  # remove 3 additional cells. Different for the other runs
    ny_mhd = ny
    nz_mhd = nz
    lx_mhd = x.max() - x.min()
    ly_mhd = y.max() - y.min()
    lz_mhd = z.max() - z.min()
    mpi_sizex = 16  # arbitrary since they are not used anymore
    mpi_sizey = 16
    mpi_sizez = 1
    if nx_mhd > 0:
        double_data[0] = lx_mhd / nx_mhd
    else:
        double_data[0] = 0.0
    if ny_mhd > 0:
        double_data[1] = ly_mhd / ny_mhd
    else:
        double_data[1] = 0.0
    if nz_mhd > 0:
        double_data[2] = lz_mhd / nz_mhd
    else:
        double_data[2] = 0.0
    double_data[3] = x.min()
    double_data[4] = y.min()
    double_data[5] = z.min()
    double_data[6] = x.max()
    double_data[7] = y.max()
    double_data[8] = z.max()
    double_data[9] = lx_mhd
    double_data[10] = ly_mhd
    double_data[11] = lz_mhd
    double_data[12] = 0.02
    int_data[0] = nx_mhd
    int_data[1] = ny_mhd
    int_data[2] = nz_mhd
    int_data[3] = nx_mhd // mpi_sizex
    int_data[4] = ny_mhd // mpi_sizey
    int_data[5] = nz_mhd // mpi_sizez
    int_data[6] = mpi_sizex
    int_data[7] = mpi_sizey
    int_data[8] = mpi_sizez
    int_data[9] = 9
    int_data[10] = 0  # Periodic boundary condition as default

    fname = out_dir + 'mhd_config.dat'
    double_data.tofile(fname)
    with open(fname, 'a') as file_handler:
        int_data.tofile(file_handler)


def reorganize_one_frame(tframe):
    """Reorganize one frame of 3D data by Athena MHD code
    """
    fname = mhd_run_path + "comb/flarecs." + str(tframe).zfill(4) + ".vtk"
    fdata = read(fname)
    nz, ny, nx = fdata["bx"].shape

    x = fdata["x"][1:-2]  # remove 3 additional cells
    y = fdata["y"]
    z = fdata["z"]

    save_config(x, y, z)

    # MHD fields with ghost cells
    nx -= 3  # remove 3 additional cells
    ng = 2  # Number of ghost cells
    mhd_fields = np.zeros((nz + ng * 2, ny + ng * 2, nx + ng * 2, 8),
                          dtype=np.float32)
    ixs, ixe = ng, nx + ng
    iys, iye = ng, ny + ng
    izs, ize = ng, nz + ng
    irho = 1.0 / fdata["rho"][:, :, 1:-2]
    mhd_fields[izs:ize, iys:iye, ixs:ixe, 0] = fdata["mx"][:, :, 1:-2] * irho
    mhd_fields[izs:ize, iys:iye, ixs:ixe, 1] = fdata["my"][:, :, 1:-2] * irho
    mhd_fields[izs:ize, iys:iye, ixs:ixe, 2] = fdata["mz"][:, :, 1:-2] * irho
    mhd_fields[izs:ize, iys:iye, ixs:ixe, 3] = fdata["rho"][:, :, 1:-2]
    mhd_fields[izs:ize, iys:iye, ixs:ixe, 4] = fdata["bx"][:, :, 1:-2]
    mhd_fields[izs:ize, iys:iye, ixs:ixe, 5] = fdata["by"][:, :, 1:-2]
    mhd_fields[izs:ize, iys:iye, ixs:ixe, 6] = fdata["bz"][:, :, 1:-2]
    cond = np.isnan(mhd_fields[:, :, :, 6])
    mhd_fields[cond, 6] = 0.0
    mhd_fields[:, :, :,
               7] = np.sqrt(np.sum(mhd_fields[:, :, :, 4:7]**2, axis=3))

    bcxs = range(ixs + ng - 1, ixs - 1, -1)
    bcys = range(iys + ng - 1, ixs - 1, -1)
    if zboundary_open:
        bczs = range(izs + ng - 1, izs - 1, -1)  # open
    else:
        bczs = range(izs, izs + ng)  # periodic
    bcxe = range(ixe - ng + 1, ixe - ng - 1, -1)
    bcye = range(iye - ng + 1, iye - ng - 1, -1)
    if zboundary_open:
        bcze = range(ize - ng + 1, ize - ng - 1, -1)  # open
    else:
        bcze = range(ize - ng, ize)  # periodic
    if zboundary_open:
        mhd_fields[:izs, :, :, :] = mhd_fields[bczs, :, :, :]  # open
    else:
        mhd_fields[:izs, :, :, :] = mhd_fields[bcze, :, :, :]  # periodic
    mhd_fields[:, :iys, :, :] = mhd_fields[:, bcys, :, :]
    mhd_fields[:, :, :ixs, :] = mhd_fields[:, :, bcxs, :]
    if zboundary_open:
        mhd_fields[ize:, :, :, :] = mhd_fields[bcze, :, :, :]  # open
    else:
        mhd_fields[ize:, :, :, :] = mhd_fields[bczs, :, :, :]  # periodic
    mhd_fields[:, iye:, :, :] = mhd_fields[:, bcye, :, :]
    mhd_fields[:, :, ixe:, :] = mhd_fields[:, :, bcxe, :]

    if zboundary_open:
        # open along z
        mhd_fields[:izs, :iys, :ixs, :] = mhd_fields[bczs, bcys, bcxs, :]
        mhd_fields[:izs, :iys, ixe:, :] = mhd_fields[bczs, bcys, bcxe, :]
        mhd_fields[:izs, iye:, :ixs, :] = mhd_fields[bczs, bcye, bcxs, :]
        mhd_fields[:izs, iye:, ixe:, :] = mhd_fields[bczs, bcye, bcxe, :]
        mhd_fields[ize:, :iys, :ixs, :] = mhd_fields[bcze, bcys, bcxs, :]
        mhd_fields[ize:, :iys, ixe:, :] = mhd_fields[bcze, bcys, bcxe, :]
        mhd_fields[ize:, iye:, :ixs, :] = mhd_fields[bcze, bcye, bcxs, :]
        mhd_fields[ize:, iye:, ixe:, :] = mhd_fields[bcze, bcye, bcxe, :]
    else:
        # periodic along z
        mhd_fields[:izs, :iys, :ixs, :] = mhd_fields[bcze, bcys, bcxs, :]
        mhd_fields[:izs, :iys, ixe:, :] = mhd_fields[bcze, bcys, bcxe, :]
        mhd_fields[:izs, iye:, :ixs, :] = mhd_fields[bcze, bcye, bcxs, :]
        mhd_fields[:izs, iye:, ixe:, :] = mhd_fields[bcze, bcye, bcxe, :]
        mhd_fields[ize:, :iys, :ixs, :] = mhd_fields[bczs, bcys, bcxs, :]
        mhd_fields[ize:, :iys, ixe:, :] = mhd_fields[bczs, bcys, bcxe, :]
        mhd_fields[ize:, iye:, :ixs, :] = mhd_fields[bczs, bcye, bcxs, :]
        mhd_fields[ize:, iye:, ixe:, :] = mhd_fields[bczs, bcye, bcxe, :]

    print("Min and Max of vx: %f, %f" %
          (mhd_fields[:, :, :, 0].min(), mhd_fields[:, :, :, 0].max()))
    print("Min and Max of vy: %f, %f" %
          (mhd_fields[:, :, :, 1].min(), mhd_fields[:, :, :, 1].max()))
    print("Min and Max of vz: %f, %f" %
          (mhd_fields[:, :, :, 2].min(), mhd_fields[:, :, :, 2].max()))
    print("Min and Max of rho: %f, %f" %
          (mhd_fields[:, :, :, 3].min(), mhd_fields[:, :, :, 3].max()))
    print("Min and Max of bx: %f, %f" %
          (mhd_fields[:, :, :, 4].min(), mhd_fields[:, :, :, 4].max()))
    print("Min and Max of by: %f, %f" %
          (mhd_fields[:, :, :, 5].min(), mhd_fields[:, :, :, 5].max()))
    print("Min and Max of bz: %f, %f" %
          (mhd_fields[:, :, :, 6].min(), mhd_fields[:, :, :, 6].max()))
    print("Min and Max of B-field: %f, %f" %
          (mhd_fields[:, :, :, 7].min(), mhd_fields[:, :, :, 7].max()))

    fname = out_dir + 'mhd_data_' + str(tframe).zfill(4)
    mhd_fields.tofile(fname)

    rho = np.zeros((nz + ng * 2, ny + ng * 2, nx + ng * 2), dtype=np.float32)
    pre = np.zeros((nz + ng * 2, ny + ng * 2, nx + ng * 2), dtype=np.float32)
    rho[izs:ize, iys:iye, ixs:ixe] = fdata["rho"][:, :, 1:-2]
    pre[izs:ize, iys:iye, ixs:ixe] = fdata["p"][:, :, 1:-2]

    if zboundary_open:
        rho[:izs, :, :] = rho[bczs, :, :]  # open
    else:
        rho[:izs, :, :] = rho[bcze, :, :]  # periodic
    rho[:, :iys, :] = rho[:, bcys, :]
    rho[:, :, :ixs] = rho[:, :, bcxs]
    if zboundary_open:
        rho[ize:, :, :] = rho[bcze, :, :]  # open
    else:
        rho[ize:, :, :] = rho[bczs, :, :]  # periodic
    rho[:, iye:, :] = rho[:, bcye, :]
    rho[:, :, ixe:] = rho[:, :, bcxe]

    if zboundary_open:
        pre[:izs, :, :] = pre[bczs, :, :]  # open
    else:
        pre[:izs, :, :] = pre[bcze, :, :]  # periodic
    pre[:, :iys, :] = pre[:, bcys, :]
    pre[:, :, :ixs] = pre[:, :, bcxs]
    if zboundary_open:
        pre[ize:, :, :] = pre[bcze, :, :]  # open
    else:
        pre[ize:, :, :] = pre[bczs, :, :]  # periodic
    pre[:, iye:, :] = pre[:, bcye, :]
    pre[:, :, ixe:] = pre[:, :, bcxe]

    if zboundary_open:
        # open along z
        rho[:izs, :iys, :ixs] = rho[bczs, bcys, bcxs]
        rho[:izs, :iys, ixe:] = rho[bczs, bcys, bcxe]
        rho[:izs, iye:, :ixs] = rho[bczs, bcye, bcxs]
        rho[:izs, iye:, ixe:] = rho[bczs, bcye, bcxe]
        rho[ize:, :iys, :ixs] = rho[bcze, bcys, bcxs]
        rho[ize:, :iys, ixe:] = rho[bcze, bcys, bcxe]
        rho[ize:, iye:, :ixs] = rho[bcze, bcye, bcxs]
        rho[ize:, iye:, ixe:] = rho[bcze, bcye, bcxe]
        pre[:izs, :iys, :ixs] = pre[bczs, bcys, bcxs]
        pre[:izs, :iys, ixe:] = pre[bczs, bcys, bcxe]
        pre[:izs, iye:, :ixs] = pre[bczs, bcye, bcxs]
        pre[:izs, iye:, ixe:] = pre[bczs, bcye, bcxe]
        pre[ize:, :iys, :ixs] = pre[bcze, bcys, bcxs]
        pre[ize:, :iys, ixe:] = pre[bcze, bcys, bcxe]
        pre[ize:, iye:, :ixs] = pre[bcze, bcye, bcxs]
        pre[ize:, iye:, ixe:] = pre[bcze, bcye, bcxe]
    else:
        # periodic along z
        rho[:izs, :iys, :ixs] = rho[bcze, bcys, bcxs]
        rho[:izs, :iys, ixe:] = rho[bcze, bcys, bcxe]
        rho[:izs, iye:, :ixs] = rho[bcze, bcye, bcxs]
        rho[:izs, iye:, ixe:] = rho[bcze, bcye, bcxe]
        rho[ize:, :iys, :ixs] = rho[bczs, bcys, bcxs]
        rho[ize:, :iys, ixe:] = rho[bczs, bcys, bcxe]
        rho[ize:, iye:, :ixs] = rho[bczs, bcye, bcxs]
        rho[ize:, iye:, ixe:] = rho[bczs, bcye, bcxe]

        pre[:izs, :iys, :ixs] = pre[bcze, bcys, bcxs]
        pre[:izs, :iys, ixe:] = pre[bcze, bcys, bcxe]
        pre[:izs, iye:, :ixs] = pre[bcze, bcye, bcxs]
        pre[:izs, iye:, ixe:] = pre[bcze, bcye, bcxe]
        pre[ize:, :iys, :ixs] = pre[bczs, bcys, bcxs]
        pre[ize:, :iys, ixe:] = pre[bczs, bcys, bcxe]
        pre[ize:, iye:, :ixs] = pre[bczs, bcye, bcxs]
        pre[ize:, iye:, ixe:] = pre[bczs, bcye, bcxe]

    print("Min and Max of rho: %f, %f" % (rho.min(), rho.max()))
    print("Min and Max of pressure: %f, %f" % (pre.min(), pre.max()))

    fname = out_dir + 'rho_' + str(tframe).zfill(4)
    rho.tofile(fname)
    fname = out_dir + 'pre_' + str(tframe).zfill(4)
    pre.tofile(fname)

    if tframe == 0:
        x.tofile(out_dir + "xpos.dat")
        y.tofile(out_dir + "ypos.dat")
        z.tofile(out_dir + "zpos.dat")


def process_input(tframe):
    print("Time frame: %d" % tframe)
    reorganize_one_frame(tframe)


tframes = range(tmin, tmax + 1)
ncores = multiprocessing.cpu_count()
ncores = 8
Parallel(n_jobs=ncores)(delayed(process_input)(tframe) for tframe in tframes)
